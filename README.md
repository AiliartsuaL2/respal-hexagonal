## 헥사고날 아키텍처 기반 Respal

### 설계 방법
1. 도메인별 행동을 정의한다.
2. 행동을 기반으로 유스케이스를 정의한다.

### 아키텍처 규칙
- 도메인별 패키지 구분
- 행동 (기능) 단위로 분리
- Layer
  - 외부에서 내부로 (domain <- application <- adapter) 의존한다.
  - Adapter : 외부와 연결되는 역할
    - 포트 인터페이스를 통하지 않고서는 외부에서 접근을 하면 안됨 -> package-private(default)
    - in 
      - web
        - Http 요청을 수신하여 UseCase를 통해 비즈니스로직을 실행 후 응답한다. 
          - Http와 관련된 것들은 애플리케이션 계층으로 침투해서는 안된다.
        - 가능한 좁고 다른 컨트롤러와 가능한 적게 공유하게끔 구현
          - package-private 클래스로 선언하여 다른 곳에서 재사용 될 일 없도록 처리
          - 컨트롤러명에 행동에 대한 정의가 들어갈 수록 좋다.
          - 유지보수적인 측면의 장점 
            - 코드가 길어지면 해당 코드를 파악하는데에 난이도가 높아짐
            - 테스트 코드의 경우 더욱 추상적이기 때문에 코드가 길어지면 더욱 어려워짐.
            - 모든 연산을 단일 컨트롤러에 넣을 경우, 데이터의 구조 재활용을 촉진한다.
              - DTO등을 재사용하며 필요없는 필드들이 들어가는경우, 헷갈릴 수 있음
            - Merge Conflict 가능성을 줄여준다.
        - process
          1. Http 요청을 자바 객체로 매핑
          2. 권한 검사
          3. 입력 유효성 검증
             - **웹 어댑터의 입력 모델을 유스케이스의 입력 모델로 변환 할 수 있다는 것**을 검증한다.
          4. 입력을 유스케이스의 입력 모델로 매핑
          5. 유스케이스 호출
          6. 유스케이스의 출력을 Http로 매핑
          7. Http 응답을 반환
    - out
      - persistence
        - 도메인별 영속성 어댑터를 분리한다.
        - 도메인 코드는 포트에 의해 정의된 명세를 어떤 클래스가 충족시키는지에 관심이 없다.
          - 필요에 따라 영속성 어댑터를 많은 클래스로 나누어 JPA나 Mongo처럼 구현체를 다르게 두자.
        - 영속성 측면과의 타협 없이 풍부한 도메인 모델을 생성하고 싶다면, 도메인 모델과 영속성 모델을 따로 만들어 매핑하는것이 좋다.
        - process
          1. 입력을 받는다.
          2. 입력을 데이터베이스 포멧으로 매핑한다.
          3. 입력을 데이터베이스로 보낸다.
          4. 데이터베이스 출력을 애플리케이션(Java) 포맷으로 매핑한다.
          5. 출력을 반환한다.
  - Application 
    - service
      - UseCase들의 구현체, 실질적 비즈니스 로직 담당
      - incoming port를 통해서만 접근이 가능해야함 -> public x
      - @Transactional 담당 -> 비즈니스 로직에 대해 구현을 하고 있기 때문에, 트랙잭션을 담당
        - 해당 애노테이션으로 오염되지 않기를 기대한다면 AspectJ를 이용해 AOP로 트랜잭션 경계를 코드에 위빙 가능
    - port
      - in
        - UseCase : **비즈니스 규칙** 검증 담당
          - incoming Adapter로부터 입력을 받음. -> public
          - 입력 유효성 검증을 하지않고 비즈니스 로직을 검증해야함.
            - service가 아닌, service로 전달해주는 dto를 통해 입력 유효성을 검증해야함
            - 입력 유효성과 비즈니스 로직의 검증 방법 : 모델의 현재 상태 참조 유무에 따라 결정
              - 단순 DB 조회의 경우나 여의치 않은 경우 UseCase에서 검증한다.
              - 로직이 복잡해져서 도메인 모델에 로드해서 검증하는경우 도메인 내부에서 검증을 한다.
          - 읽기 전용 유스케이스 (단순히 DB로부터 도메인의 상태 조회만 필요한 경우)
            - 쿼리를 위한 인커밍 전용 포트 추가 후 쿼리 서비스에 구현
            - 쓰기가 가능한 유스케이스와 읽기 전용 쿼리를 분리 (CQS, CQRS)
          - process
            1. 입력을 받는다.
            2. 비즈니스 규칙을 검증한다. (비즈니스 규칙 검증하여 모델의 상태를 변경)
            3. 모델 상태를 조작한다. (영속성 어댑터를 통해 구현된 포트로 전달하여 데이터 저장)
            4. 출력을 반환한다. (해당 유스케이스를 호출한 어댑터로 반환할 출력 객체로 변환하여 반환)
               - 각 유스케이스에 맞게 구체적(최소화)으로 출력한다.
                 - 유스케이스들간 출력 모델을 공유하게되면, 유스케이스들끼리의 커플링이 올라감.
               - 호출자에게 꼭 필요한 데이터만 들고있어야 한다.
      - out
        - Persistence Adapter와 application 연결
          - 좁은 포트 인터페이스를 사용하여 의존성을 분리시킨다.
            - 기능 단위로 작게 분리하여 의존성을 분리시키면 테스트시 어떤 메서드를 모킹 할 지, 했는지 불필요한 확인이 없어지고, 필요한 포트에 단순히 꽂기만 하면 작동이 되도록 코드를 작성 할 수 있다.
  - Domain
    - 도메인 및 행동 정의
    - 풍부한 도메인 모델
      - ✅ 엔티티에서 가능한 많은 도메인 로직 구현 -> 객체지향적 접근을 위해 해당 모델 적용
    - 빈약한 도메인 모델
      - 엔티티에는 상태를 갖는 필드만 정의 후 유스케이스에서 구현
- Test
  ![테스트 피라미드](https://github.com/AiliartsuaL2/respal-hexagonal/assets/89395238/b7878e69-8cde-4075-87b3-bad9c0a3df39) 
  - 테스트 피라미드를 따른다.
    - 만드는 비용이 적고, 유지보수가 쉽고, 빨리 실행되는 단위 테스트에 대해 높은 테스트 커버리지를 유지해야 한다.
      - 단위와 단위를 넘고, 아키텍쳐 및 시스템 경계를 결합하는 테스트는 만드는 비용 > 기능 추가 비용이 된다.
    - 단위 테스트
      - 다른 클래스에 의존한다면 의존하는 클래스들은 인스턴스화 하지 않고 목킹으로 대체
      - 도메인 엔티티 테스트
        - 도메인 클래스에서 정의한 특정 메서드를 테스트. 단순히 입력에 대한 기댓값이 정상적으로 반영되었는지 확인
      - 유스케이스 테스트
        - 모든 동작을 검증하는 대신 주요한 핵심만 골라 집중해서 테스트를 해야한다.
          - 모든 동작 검증시, 클래스가 변경 될 때마다 테스트를 변경해야함 -> 테스트 가치가 떨어짐.
    - 통합 테스트
      - 연결된 여러 유닛들을 인스턴스화 하고, 시작점이 되는 클래스의 인터페이스로 데이터를 보낸 후 유닛들의 네트워크가 기대한대로 잘 동작하는지 검증한다.
      - 두 계층간 경계를 걸쳐 테스트 할 수 있기 때문에 어떤 시점에는 목을 대상으로 수행한다.
      - 웹 어댑터 테스트
        - @WebMvcTest : 스프링이 특정 요청 경로, Java <-> Json간 매핑, Http 입력 검증 등에 대한 필요한 전체 객체 네트워크를 인스턴스화
        - Json 문자열 형태로 Http를 통해 입력을 받아 입력에 대한 유효성을 검증 후 유스케이스에 전달 -> 결과를 Json으로 매핑 후 Http 응답
        - MockMvc 객체를 통해 모킹하여 검증 -> 스프링 프레임워크(Json <-> Java, Http 입력 검증 등)와 통합하여 테스트를 진행
      - 영속성 어댑터 테스트
        - @DataJpaTest : @Repository로 선언된 객체 네트워크를 인스턴스화 시킴
        - @Import : 특정 객체가 이 네트워크에 추가됨을 알림
        - 데이터베이스간 매핑 검증
        - 데이터베이스는 모킹하지 않음 -> 실제 DB와 연동시 SQL 오류 혹은 DB <-> 자바 객체 매핑간 에러등의 문제 사전 체크
        - 프로덕션 환경에선 인메모리를 사용하지않는 부분(DBMS Dialect 등) 때문에 테스트 코드에선 실제 DB로 테스트해야함.
    - 시스템 테스트
      - SpringBootTest : 스프링이 애플리케이션을 구성하는 모든 객체 네트워크를 띄워 테스트
      - 애플리케이션을 구성하는 모든 객체 네트워크를 가동시켜 **특정 유스케이스**가 **전 계층**에서 잘 동작하는지 검증
      - 특정 시나리오를 만들 때 더 빛이 남. (경로 지정 등)
      - 주요 경로 테스트
        - 전체 애플리케이션을 띄워 API를 통해 요청을 보내고, 모든 계층이 조화롭게 잘 동작하는지 검증한다.
        - MockMvc가 아닌 TestRestTemplate 사용
          - 테스트 프로덕션 환경에 조금 더 가깝게 하기 위해 실제 Http 통신 사용
  - 라인 커버리지는 테스트 성공을 측정하는데 있어서는 잘못된 지표
    - 코드의 중요한 부분이 전혀 커버가 되지 않을 수 있기 때문
  - 자주 배포 할 수록 테스트의 신뢰도가 높아진다.
  - 각각의 프로덕션 버그에 대해 테스트가 왜 이 버그를 잡지 못한지에 대한 생각을 기록하고 테스트 코드를 추가해야함.
  - 테스트가 기능 개발 후가 아닌 개발 중에 이루어져야함. (귀찮은 일 -> 개발 도구)
  - 필드를 변경하거나 구조가 변경 될 때 테스트가 취약한 경우 개선을 해야함 (테스트로서의 가치를 잃기 때문)
  - 육각형 아키텍쳐에서 사용하는 테스트 전략
    - 포트는 뚜렷한 모킹 지점이 된다.
      - 포트 인터페이스가 아주 작고 핵심만 담고 있다면 모킹하는것이 아주 쉬움
      - 모킹하기 어려워지거나 코드의 특정 부분을 커버하기 위해 어떤 종류의 테스트를 써야 할 지 모르겠다면 경고신호.
    - 도메인 엔티티를 **구현 할 때**에는 단위 테스트로 커버
    - 유스케이스를 **구현 할 때**에는 단위 테스트로 커버
    - 어댑터를 **구현 할 때**에는 통합 테스트로 커버
    - 사용자가 취할 수 있는 중요 애플리케이션 경로는 시스템 테스트로 커버
