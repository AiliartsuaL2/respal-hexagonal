## 헥사고날 아키텍처 기반 Respal

### 설계 방법
1. 도메인별 행동을 정의한다.
2. 행동을 기반으로 유스케이스를 정의한다.

### 아키텍처 규칙
- 도메인별 패키지 구분
- 행동 (기능) 단위로 분리
- Layer
  - 외부에서 내부로 (domain <- application <- adapter) 의존한다.
  - Adapter : 외부와 연결되는 역할
    - 포트 인터페이스를 통하지 않고서는 외부에서 접근을 하면 안됨 -> package-private(default)
    - in 
      - web
        - Http 요청을 수신하여 UseCase를 통해 비즈니스로직을 실행 후 응답한다. 
          - Http와 관련된 것들은 애플리케이션 계층으로 침투해서는 안된다.
        - 가능한 좁고 다른 컨트롤러와 가능한 적게 공유하게끔 구현
          - package-private 클래스로 선언하여 다른 곳에서 재사용 될 일 없도록 처리
          - 컨트롤러명에 행동에 대한 정의가 들어갈 수록 좋다.
          - 유지보수적인 측면의 장점 
            - 코드가 길어지면 해당 코드를 파악하는데에 난이도가 높아짐
            - 테스트 코드의 경우 더욱 추상적이기 때문에 코드가 길어지면 더욱 어려워짐.
            - 모든 연산을 단일 컨트롤러에 넣을 경우, 데이터의 구조 재활용을 촉진한다.
              - DTO등을 재사용하며 필요없는 필드들이 들어가는경우, 헷갈릴 수 있음
            - Merge Conflict 가능성을 줄여준다.
        - process
          1. Http 요청을 자바 객체로 매핑
          2. 권한 검사
          3. 입력 유효성 검증
             - **웹 어댑터의 입력 모델을 유스케이스의 입력 모델로 변환 할 수 있다는 것**을 검증한다.
          4. 입력을 유스케이스의 입력 모델로 매핑
          5. 유스케이스 호출
          6. 유스케이스의 출력을 Http로 매핑
          7. Http 응답을 반환
    - out
      - persistence
        - 도메인별 영속성 어댑터를 분리한다.
        - 도메인 코드는 포트에 의해 정의된 명세를 어떤 클래스가 충족시키는지에 관심이 없다.
          - 필요에 따라 영속성 어댑터를 많은 클래스로 나누어 JPA나 Mongo처럼 구현체를 다르게 두자.
        - 영속성 측면과의 타협 없이 풍부한 도메인 모델을 생성하고 싶다면, 도메인 모델과 영속성 모델을 따로 만들어 매핑하는것이 좋다.
        - process
          1. 입력을 받는다.
          2. 입력을 데이터베이스 포멧으로 매핑한다.
          3. 입력을 데이터베이스로 보낸다.
          4. 데이터베이스 출력을 애플리케이션(Java) 포맷으로 매핑한다.
          5. 출력을 반환한다.
  - Application 
    - service
      - UseCase들의 구현체, 실질적 비즈니스 로직 담당
      - incoming port를 통해서만 접근이 가능해야함 -> public x
      - @Transactional 담당 -> 비즈니스 로직에 대해 구현을 하고 있기 때문에, 트랙잭션을 담당
        - 해당 애노테이션으로 오염되지 않기를 기대한다면 AspectJ를 이용해 AOP로 트랜잭션 경계를 코드에 위빙 가능
    - port
      - in
        - UseCase : **비즈니스 규칙** 검증 담당
          - incoming Adapter로부터 입력을 받음. -> public
          - 입력 유효성 검증을 하지않고 비즈니스 로직을 검증해야함.
            - service가 아닌, service로 전달해주는 dto를 통해 입력 유효성을 검증해야함
            - 입력 유효성과 비즈니스 로직의 검증 방법 : 모델의 현재 상태 참조 유무에 따라 결정
              - 단순 DB 조회의 경우나 여의치 않은 경우 UseCase에서 검증한다.
              - 로직이 복잡해져서 도메인 모델에 로드해서 검증하는경우 도메인 내부에서 검증을 한다.
          - 읽기 전용 유스케이스 (단순히 DB로부터 도메인의 상태 조회만 필요한 경우)
            - 쿼리를 위한 인커밍 전용 포트 추가 후 쿼리 서비스에 구현
            - 쓰기가 가능한 유스케이스와 읽기 전용 쿼리를 분리 (CQS, CQRS)
          - process
            1. 입력을 받는다.
            2. 비즈니스 규칙을 검증한다. (비즈니스 규칙 검증하여 모델의 상태를 변경)
            3. 모델 상태를 조작한다. (영속성 어댑터를 통해 구현된 포트로 전달하여 데이터 저장)
            4. 출력을 반환한다. (해당 유스케이스를 호출한 어댑터로 반환할 출력 객체로 변환하여 반환)
               - 각 유스케이스에 맞게 구체적(최소화)으로 출력한다.
                 - 유스케이스들간 출력 모델을 공유하게되면, 유스케이스들끼리의 커플링이 올라감.
               - 호출자에게 꼭 필요한 데이터만 들고있어야 한다.
      - out
        - Persistence Adapter와 application 연결
          - 좁은 포트 인터페이스를 사용하여 의존성을 분리시킨다.
            - 기능 단위로 작게 분리하여 의존성을 분리시키면 테스트시 어떤 메서드를 모킹 할 지, 했는지 불필요한 확인이 없어지고, 필요한 포트에 단순히 꽂기만 하면 작동이 되도록 코드를 작성 할 수 있다.
  - Domain
    - 도메인 및 행동 정의
    - 풍부한 도메인 모델
      - ✅ 엔티티에서 가능한 많은 도메인 로직 구현 -> 객체지향적 접근을 위해 해당 모델 적용
    - 빈약한 도메인 모델
      - 엔티티에는 상태를 갖는 필드만 정의 후 유스케이스에서 구현
